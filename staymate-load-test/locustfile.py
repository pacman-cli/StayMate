import json
import random
import uuid
import datetime
import logging
from locust import HttpUser, task, between, tag

# --- Configuration ---
ADMIN_EMAIL = "mpuspo2310304@bscse.uiu.ac.bd"
ADMIN_PASSWORD = "MdAshikur123+"
HOST = "http://localhost:8080"

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class StayMateUser(HttpUser):
    """Base class for all StayMate users handling Auth and common headers."""

    abstract = True
    token = None
    user_id = None
    email = None
    password = "password123"
    role_label = "User"  # Default label for reports

    @property
    def headers(self):
        h = {"Content-Type": "application/json"}
        if self.token:
            h["Authorization"] = f"Bearer {self.token}"
        return h

    def req_name(self, action):
        """Helper to prefix request names with role for granular reporting."""
        return f"[{self.role_label}] {action}"

    def register(self, role):
        """Registers a new user with a random email and specific role."""
        uid = uuid.uuid4().hex[:8]
        self.email = f"loadtest_{role.lower()}_{uid}@example.com"

        payload = {
            "email": self.email,
            "password": self.password,
            "firstName": f"Test{role.capitalize()}",
            "lastName": uid,
            "phoneNumber": f"555{random.randint(1000000, 9999999)}",
            "role": role,
            "bio": "Load testing user generated by Locust",
        }

        # Auth requests are usually global, but we can tag them too if we want
        with self.client.post(
            "/api/auth/register",
            json=payload,
            catch_response=True,
            name="[Auth] Register",
        ) as response:
            if response.status_code in [200, 201]:
                data = response.json()
                self.token = data.get("accessToken")
                self.user_id = data.get("userId")
            else:
                response.failure(f"Register failed for {self.email}: {response.text}")

    def login(self, email, password):
        """Logs in an existing user."""
        payload = {"email": email, "password": password}
        with self.client.post(
            "/api/auth/login", json=payload, catch_response=True, name="[Auth] Login"
        ) as response:
            if response.status_code == 200:
                data = response.json()
                self.token = data.get("accessToken")
                self.user_id = data.get("userId")
            else:
                response.failure(f"Login failed for {email}: {response.text}")

    @task(5)
    @tag("notifications")
    def check_notifications(self):
        """High frequency polling for notifications."""
        if not self.token:
            return
        self.client.get(
            "/api/notifications",
            headers=self.headers,
            name=self.req_name("Check Notifications"),
        )

    @task(1)
    @tag("messaging")
    def check_messages(self):
        """Check conversations."""
        if not self.token:
            return
        self.client.get(
            "/api/messages/conversations",
            headers=self.headers,
            name=self.req_name("Check Conversations"),
        )


class TenantUser(StayMateUser):
    """Simulates a Tenant who searches, saves, books, finds roommates, and messages."""

    wait_time = between(2, 6)
    weight = 7
    role_label = "Tenant"

    # State to share data between tasks
    viewed_properties = []

    def on_start(self):
        self.register("USER")
        if random.random() < 0.1:
            self.request_verification()

    def request_verification(self):
        if not self.token:
            return
        headers = self.headers.copy()
        headers.pop("Content-Type", None)
        files = {"document": ("id_card.jpg", b"fake_image_bytes", "image/jpeg")}
        self.client.post(
            "/api/verification/request",
            files=files,
            headers=headers,
            name=self.req_name("Request Verification"),
        )

    @task(4)
    @tag("search")
    def search_and_browse(self):
        min_p = random.choice([10, 50, 100])
        max_p = min_p + random.randint(100, 1000)

        with self.client.get(
            f"/api/properties/search?minPrice={min_p}&maxPrice={max_p}",
            headers=self.headers,
            catch_response=True,
            name=self.req_name("Search Properties"),
        ) as response:
            if response.status_code == 200:
                properties = response.json()
                if properties:
                    prop = properties[0]  # Just pick first for simplicity in deep logic
                    self.viewed_properties.append(prop)
                    if len(self.viewed_properties) > 10:
                        self.viewed_properties.pop(0)

                    self.view_property_details(prop["id"])
                    self.view_reviews(prop["id"])

    def view_property_details(self, prop_id):
        self.client.get(
            f"/api/properties/{prop_id}",
            headers=self.headers,
            name=self.req_name("View Property Details"),
        )
        if random.random() < 0.2:
            self.client.post(
                f"/api/saved/properties/{prop_id}",
                headers=self.headers,
                name=self.req_name("Save Property"),
            )

    def view_reviews(self, prop_id):
        self.client.get(
            f"/api/reviews/property/{prop_id}",
            headers=self.headers,
            name=self.req_name("View Reviews"),
        )

    @task(1)
    @tag("booking")
    def create_booking(self):
        if not self.token or not self.viewed_properties:
            return

        target = random.choice(self.viewed_properties)
        if target.get("ownerId") == self.user_id:
            return

        start = datetime.date.today() + datetime.timedelta(days=random.randint(1, 60))
        end = start + datetime.timedelta(days=random.randint(2, 10))

        payload = {
            "propertyId": target["id"],
            "landlordId": target["ownerId"],
            "startDate": str(start),
            "endDate": str(end),
            "notes": f"Load test booking request from {self.email}",
        }

        with self.client.post(
            "/api/bookings",
            json=payload,
            headers=self.headers,
            catch_response=True,
            name=self.req_name("Create Booking"),
        ) as req:
            if req.status_code in [200, 201]:
                self.send_message(target["ownerId"], "Hi, I just requested a booking!")
            elif req.status_code == 400:
                req.success()

    def send_message(self, recipient_id, content):
        payload = {"receiverId": recipient_id, "content": content}
        self.client.post(
            "/api/messages/send",
            json=payload,
            headers=self.headers,
            name=self.req_name("Send Message"),
        )

    @task(2)
    @tag("roommates")
    def roommate_actions(self):
        if not self.token:
            return

        # Check standard matches (DB)
        self.client.get(
            "/api/matches", headers=self.headers, name=self.req_name("Get My Matches")
        )

        # Browse roommate posts
        self.client.get(
            "/api/roommates",
            headers=self.headers,
            name=self.req_name("Browse Roommates"),
        )

        if random.random() < 0.05:
            payload = {
                "location": "TestCity",
                "budget": random.randint(300, 1000),
                "moveInDate": str(datetime.date.today() + datetime.timedelta(days=30)),
                "bio": "Looking for a roommate!",
                "preferences": {"smoking": False, "pets": True},
            }
            self.client.post(
                "/api/roommates",
                json=payload,
                headers=self.headers,
                name=self.req_name("Create Roommate Post"),
            )

    @task(1)
    @tag("ai")
    def use_ai_features(self):
        """Simulate AI usage (Heavy Compute)."""
        if not self.token:
            return

        # Trigger LLM Matching (Low probability because it is heavy)
        if random.random() < 0.1:
            self.client.post(
                "/api/ai/match",
                headers=self.headers,
                name=self.req_name("AI Match (Heavy)"),
            )

    @task(1)
    def check_my_bookings(self):
        if not self.token:
            return
        self.client.get(
            "/api/bookings/my-bookings",
            headers=self.headers,
            name=self.req_name("My Bookings"),
        )


class LandlordUser(StayMateUser):
    """Simulates a Landlord creating properties and managing requests."""

    wait_time = between(5, 10)
    weight = 2
    role_label = "Landlord"

    def on_start(self):
        self.register("HOUSE_OWNER")

    @task(1)
    @tag("create_property")
    def create_listing(self):
        if not self.token:
            return
        if random.random() > 0.3:
            return

        property_data = {
            "title": f"Lux Stay {uuid.uuid4().hex[:6]}",
            "description": "automatically generated for load testing",
            "price": random.randint(80, 800),
            "address": f"{random.randint(1,999)} LoadTest Blvd",
            "city": "TestCity",
            "zipCode": "90210",
            "beds": random.randint(1, 4),
            "baths": random.randint(1, 3),
            "area": random.randint(500, 3000),
            "propertyType": random.choice(["APARTMENT", "HOUSE", "STUDIO"]),
            "amenities": ["Wifi", "AC"],
        }

        headers = self.headers.copy()
        headers.pop("Content-Type", None)
        files = {"data": (None, json.dumps(property_data), "application/json")}

        with self.client.post(
            "/api/properties",
            files=files,
            headers=headers,
            catch_response=True,
            name=self.req_name("Create Property"),
        ) as response:
            if response.status_code in [200, 201]:
                pass
            else:
                response.failure(f"Create Property failed: {response.text}")

    @task(3)
    def manage_bookings(self):
        if not self.token:
            return
        with self.client.get(
            "/api/bookings/requests",
            headers=self.headers,
            catch_response=True,
            name=self.req_name("Check Booking Requests"),
        ) as response:
            if response.status_code != 200:
                return
            requests = response.json()
            for req in requests:
                if req.get("status") == "PENDING":
                    action = random.choice(["CONFIRMED", "REJECTED"])
                    self.client.patch(
                        f"/api/bookings/{req['id']}/status?status={action}",
                        headers=self.headers,
                        name=self.req_name("Update Booking Status"),
                    )
                    break


class AdminUser(StayMateUser):
    """Simulates Admin monitoring and approving properties."""

    wait_time = between(5, 10)
    weight = 1
    role_label = "Admin"

    def on_start(self):
        self.login(ADMIN_EMAIL, ADMIN_PASSWORD)

    @task(3)
    def dashboard_monitoring(self):
        if not self.token:
            return
        self.client.get(
            "/api/admin/dashboard",
            headers=self.headers,
            name=self.req_name("Dashboard Stats"),
        )

    @task(2)
    def moderate_properties(self):
        if not self.token:
            return
        with self.client.get(
            "/api/admin/properties",
            headers=self.headers,
            catch_response=True,
            name=self.req_name("List Properties"),
        ) as response:
            if response.status_code != 200:
                return
            data = response.json()
            props = data if isinstance(data, list) else data.get("content", [])
            for p in props:
                if p.get("status") == "PENDING":
                    self.client.put(
                        f"/api/admin/properties/{p['id']}/approve",
                        headers=self.headers,
                        name=self.req_name("Approve Property"),
                    )
                    break

    @task(1)
    def moderate_verifications(self):
        if not self.token:
            return
        self.client.get(
            "/api/verification/admin/pending",
            headers=self.headers,
            name=self.req_name("Check Verifications"),
        )
