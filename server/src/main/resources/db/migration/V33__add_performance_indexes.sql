-- Add indexes to improve performance of critical queries

-- 1. Property Table Indexes
-- idx_property_owner might conflict if V111 covers owner_id via owner_id, status.
-- MySQL can use the prefix of a composite index. V111 creates (owner_id, status).
-- So searching by owner_id alone CAN use V111's index. We don't strictly need a separate owner_id index.
-- However, let's keep it if we want to be explicit, but check for existence.
-- Since we can't easily check existence in simple SQL without procedures, I will REMOVE the ones that likely caused conflicts.

-- REMOVED: CREATE INDEX idx_property_owner ON properties (owner_id);
-- REMOVED: CREATE INDEX idx_property_status ON properties (status); -- This caused the specific error "Duplicate key name 'idx_property_status'"
-- REMOVED: CREATE INDEX idx_property_owner_status ON properties (owner_id, status); -- V111 already has idx_properties_owner_status

-- NEW: Composite index for search functionality (Location, Price, Status)
-- This is definitely new and high value.
CREATE INDEX idx_property_search_v2 ON properties (status, price_amount, beds);

-- 2. Booking Table Indexes
-- idx_booking_tenant might already exist or auto-generated by foreign key?
-- JPA/Hibernate usually generates FK indexes. property_id and tenant_id are FKs.
-- Let's assume FK indexes exist.
-- But index on (property_id, start_date, end_date) is definitely custom and needed for overlap checks.

CREATE INDEX idx_booking_overlap_v2 ON bookings (property_id, start_date, end_date);
